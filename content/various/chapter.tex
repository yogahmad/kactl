\chapter{Various}

\section{Known Problems}
\kactlimport{StableMarriage.h}
\kactlimport{FlowShopScheduling.h}
\kactlimport{2sat.h}
\kactlimport{KonigTheorem.h}
\kactlimport{MoserCircle.h}
\kactlimport{ChickenMcNugget.h}
\kactlimport{EulerFaceFormula.h}
\kactlimport{CayleyFormula.h}
\kactlimport{PickTheorem.h}
\kactlimport{JosephusProblem.h}
\kactlimport{ErdosGallai.h}

\section{Minimum-Cut Problems}
\subsection{Open-pit Mining}
Given DAG with value on each node (value can be negative). We can choose a node X to be removed from graph and then 
we get the value of that node to the score. Before removing node X, X SHOULD HAVE ZERO in-degree. After removing node X, all edges that outcoming from X become removed. We can do that until the graph has no node, or we can stop at any time.
What is the maximum score? Solution: Sum of positive value on each edge plus minimum cut. For every edge (a,b), Connect b to a with capacity INF. Connect every source to positive node with capacity abs(value). Connect every negative node to sink with capacity abs(value).
\subsection{Landscaping}
Given N x N grid, each cell is either low or high land. There are N trucks going straight from top to bottom and N truck going straight from left to right.
Also a cost C is added if a truck hit a land from low to high or high to low. 
We can also toggle the high of the cell and a cost D will be added. 
What is the minimum of total cost? final position of f2N trucks should be at bottom and right. Solution: Connect every cell to its neighbor with capacity C. Connect every low cell to source with capacity D. Connect every high cell to sink with capacity D.

\section{Desperate Optimization}
\kactlimport{FastRead.h}
\kactlimport{FastMod.h}
\kactlimport{ClockTime.h}

% \section{Intervals}
% \kactlimport{IntervalContainer.h}
% \kactlimport{IntervalCover.h}

\section{Misc. algorithms}
\kactlimport{TernarySearch.h}
\kactlimport{Karatsuba.h}

\section{Dynamic programming}
\kactlimport{DivideAndConquerDP.h}
\kactlimport{KnuthDP.h}

% \section{Debugging tricks}
% \begin{itemize}
% 	\item \texttt{signal(SIGSEGV, [](int) \{ \_Exit(0); \});} converts segfaults into Wrong Answers.
% 	      Similarly one can catch SIGABRT (assertion failures) and SIGFPE (zero divisions).
% 	      \texttt{\_GLIBCXX\_DEBUG} violations generate SIGABRT (or SIGSEGV on gcc 5.4.0 apparently).
% 	\item \texttt{feenableexcept(29);} kills the program on NaNs (\texttt 1), 0-divs (\texttt 4), infinities (\texttt 8) and denormals (\texttt{16}).
% \end{itemize}

\section{Optimization tricks}
\subsection{Bit hacks}
\begin{itemize}
	\item \texttt{x \& -x} is the least bit in \texttt{x}.
	\item \texttt{for (int x = m; x; ) \{ --x \&= m; ... \}} loops over all subset masks of \texttt{m} (except \texttt{m} itself).
	\item \texttt{c = x\&-x, r = x+c; (((r\^{}x) >> 2)/c) | r} is the next number after \texttt{x} with the same number of bits set.
	\item \texttt{ rep(b,0,K) rep(i,0,(1 << K)) if (i \& 1 << b) D[i] += D[i\^{}(1 << b)]; } computes all sums of subsets.
\end{itemize}
% \subsection{Pragmas}
% \begin{itemize}
% 	\item \lstinline{#pragma GCC optimize ("Ofast")} will make GCC auto-vectorize for loops and optimizes floating points better (assumes associativity and turns off denormals).
% 	\item \lstinline{#pragma GCC target ("avx,avx2")} can double performance of vectorized code, but causes crashes on old machines.
% 	\item \lstinline{#pragma GCC optimize ("trapv")} kills the program on integer overflows (but is really slow).
% \end{itemize}
% \kactlimport{BumpAllocator.h}
% \kactlimport{SmallPtr.h}
% \kactlimport{BumpAllocatorSTL.h}
% \kactlimport{Unrolling.h}
% \kactlimport{SIMD.h}
